<!DOCTYPE html>
<html>
<head>
  <title>Functional Programming - Programming & Software Engineering</title>
  <meta charset="UTF-8">
</head>
<body>

<h1>Functional Programming</h1>
<p>Functional programming is a declarative paradigm that treats computation as the evaluation of mathematical functions and avoids changing state or mutable data.</p>

<h2>1. Core Principles</h2>
<ul>
  <li><strong>Pure Functions:</strong> Output depends only on input, with no side effects</li>
  <li><strong>Immutability:</strong> Data cannot be modified after creation</li>
  <li><strong>First-Class Functions:</strong> Functions are treated as values</li>
  <li><strong>Higher-Order Functions:</strong> Functions that take or return other functions</li>
</ul>

<h2>2. Key Concepts</h2>
<ul>
  <li><strong>Recursion:</strong> Functions call themselves to solve problems</li>
  <li><strong>Function Composition:</strong> Combine functions to build complex operations</li>
  <li><strong>Currying:</strong> Transform a function with multiple arguments into a series of single-argument functions</li>
  <li><strong>Lazy Evaluation:</strong> Delay computation until result is needed</li>
</ul>

<h2>3. Benefits of Functional Programming</h2>
<ul>
  <li><strong>Modularity:</strong> Small, reusable functions</li>
  <li><strong>Predictability:</strong> Easier reasoning due to pure functions</li>
  <li><strong>Concurrency:</strong> Safer parallel execution due to immutability</li>
  <li><strong>Testability:</strong> Functions are easier to test in isolation</li>
</ul>

<h2>4. Functional Languages</h2>
<ul>
  <li><strong>Haskell:</strong> Pure functional language</li>
  <li><strong>Scala:</strong> Combines functional and object-oriented paradigms</li>
  <li><strong>F#:</strong> Functional-first language for .NET</li>
  <li><strong>Erlang:</strong> Functional language for concurrent systems</li>
  <li><strong>Lisp:</strong> Pioneering language with functional features</li>
</ul>

<h2>5. Functional Features in Other Languages</h2>
<ul>
  <li><strong>JavaScript:</strong> Supports first-class and higher-order functions</li>
  <li><strong>Python:</strong> Includes map, filter, lambda, and functools</li>
  <li><strong>Java:</strong> Lambdas and streams in modern versions</li>
</ul>

<h2>6. Common Functional Patterns</h2>
<ul>
  <li><strong>Map:</strong> Apply a function to each element in a collection</li>
  <li><strong>Filter:</strong> Select elements based on a predicate</li>
  <li><strong>Reduce:</strong> Aggregate elements into a single value</li>
</ul>

<h2>7. Referential Transparency</h2>
<p>An expression is referentially transparent if it can be replaced with its value without changing the programâ€™s behavior.</p>

<h2>8. Side Effects and State</h2>
<ul>
  <li><strong>Side Effects:</strong> Changes in state or observable interactions (e.g., I/O)</li>
  <li><strong>Functional programming:</strong> Avoids side effects to maintain purity</li>
</ul>

<h2>9. Monads and Functors (Advanced)</h2>
<ul>
  <li><strong>Functor:</strong> Applies a function to wrapped values</li>
  <li><strong>Monad:</strong> Encapsulates computations with context (e.g., Maybe, IO)</li>
</ul>

<h2>10. Use Cases</h2>
<ul>
  <li><strong>Concurrent Systems:</strong> Safe parallelism</li>
  <li><strong>Data Transformation:</strong> Pipelines and stream processing</li>
  <li><strong>Reactive Programming:</strong> Event-driven systems</li>
  <li><strong>Mathematical Computation:</strong> Symbolic and numeric processing</li>
</ul>

</body>
  </html>
